# 

# 9.4 const and static Members

## const Variables

- Statements for constants

  ```c++
  #define VALUE 100
  
  const int value = 100
  const int * p_int; // 不能透过指针修改指针指向的内容
  int const * p_int; // 不能透过指针修改指针指向的内容
  
  int * const p_int; // 指针指向的内容可以被修改，指针不能变
  
  /*
  *常用法：保证函数内的数据不变
  */
  void func(const int *); 
  void func(const int &);
  ```

## const Members

- `const` member variables behavior similar with normal const variables
- `const` member functions promise not to modify member variables.

```c++
class Student
{
    private:
    	const int BMI = 20;
    	// ..
    public:
    Student()
    {
        BMI = 19; // Can it be modified? No.
        // ...
    }
    int getBorn() const
    {
        born++; // Can it be modified?No.
        return born;
    }
}
```

## static Members

- **static** members are not bound to class instances.

  ```cpp
  // static.cpp
  class Student
  {
  private:
  static size_t student_total; // declaration only
  public:
  Student()
  {
  student_total++;
  }
  ~Student()
  {
  student_total--;
  }
  static size_t getTotal() {return student_total;}
  };
  // definition it here
  size_t Student::student_total = 0;
  ```

  

# Chapter 10: Advances in Classes

## 10.1 operator overloading

### Function overloading

```c++
Mat add(Mat& A, Mat& B);
Mat add(Mat& A, float b);
Mat add(float a, Mat& B);
Mat mul(Mat& A, Mat& B);
Mat mul(Mat& A, float b);
Mat mul(float a, Mat& B);
```

More convenient to code as follows:

```c++
Mat A, B;
float a, b;
//...
Mat C = A + B;
Mat D = A * B;
Mat E = a * A;
```

### Operator overloading

- Customizes the C++ operators for operands of user-defined types.

- Overloaded operators are functions with special function names:  *stringdemo.cpp*

  ```c++
  std::string s("Hello ");
  s += "C";
  s.operator+=(" and CPP!");
  ```

  ![](images/Lecture10OperatorOverloading.png)

- Implementation of `operator+()` and `operator+=()`   *example1.cpp*

  ```cpp
  class MyTime
  {
  int hours;
  int minutes;
  public:
  MyTime(): hours(0), minutes(0){}
  MyTime(int h, int m): hours(h), minutes(m){}
  MyTime operator+(const MyTime & t) const
  {
  MyTime sum;
  sum.minutes = this->minutes + t.minutes;
  sum.hours = this->hours + t.hours;
  sum.hours += sum.minutes / 60;
  sum.minutes %= 60;
  return sum;
  }
  std::string getTime() const;
  ```

-  If one operand is not MyTime, and is an int

  ```cpp
  MyTime t1(2, 40);
  MyTime t2 = t1 + 20;
  ```

  The function can be:

  ```cpp
  MyTime operator+(int m) const
  {
  MyTime sum;
  sum.minutes = this->minutes + m;
  sum.hours = this->hours;
  sum.hours += sum.minutes / 60;
  sum.minutes %= 60;
  return sum;
  }
  ```

  

- We can even support the following operation to be more user friendly

  ```
  MyTime t1(2, 40);
  MyTime t2 = t1 + "one hour";
  ```

  see *example2.cpp*

- Overloaded operators is more user-friendly than functions.

- But , wait ..

  ```cpp
  t1 + 20; //operator
  t1.operator+(20); // equivalent function invoking
  ```

- How about the expression ?
  `20 + t1;`

## 10.2 friend Functions and << operator

 If we want that operator + can support `(int + MyTime)`
• Let a friend function to help
• Friend functions
Ø Declare in a class body
Ø Granted class access to members (including private members)
Ø But not members

## 10.3 Automatic Conversions and Type Casts for Classes

# Chapter 11: Dynamic Memory Management in Classes

## 11.1 Some Default Operations

### Default Constructors

Default Constructors

- Default constructor: a constructor which can be called without arguments

- If you define no constructors, the compiler automatically provide one 

  `MyTime::MyTime(){}`

-  If you define constructors, the compiler will not generate a default one

  ```c++
  class MyTime
  {
  public:
  MyTime(int n){ ... }
  };
  MyTime mt; //no appropriate constructor - Compilation failure
  ```

- To avoid ambiguous（混淆）

  ```cpp
  class MyTime
  {
  public: //two default constructors
  MyTime(){ ... }
  MyTime(int n = 0){ ... }
  };
  MyTime mt; // which constructor?- Compilation failure
  ```

### Implicitly-defined Destructor

-  If no destructor is defined, the compiler will generate an empty one.
  `MyTime::~MyTime(){}`
- Memory allocated in constructors is normally released in a destructor.
- However, the destructor that generated by compiler will not release memory automatically.

### Default Copy Constructors

- A copy constructor. Only one parameter, or the rest have default values

  `MyTime::MyTime(MyTime & t){ ... }`

  ```cpp
  MyTime t1(1, 59);
  MyTime t2(t1); //copy constructor
  MyTime t3 = t1; //copy constructor
  ```

- Default copy constructor:

  - If no user-defined copy constructors, the compiler will generate one.
  - Copy all non-static data members.

### Default Copy Assignment

- Assignment operators: =, +=, -=, ...

- Copy assignment operator 

  `MyTime & MyTime::operator=(MyTime & ){...}`

  ```cpp
  MyTime t1(1, 59);
  MyTime t2 = t1; //copy constructor
  t2 = t1; //copy assignment
  ```

- Default copy assignment operator

  - If no user-defined copy assignment constructors,
    the compiler will generate one.
  - Copy all non-static data members.

## 11.2 An example with dynamic memory

### A Simple String Class

```c++
class MyString
{
int buf_len;
char * characters;
public:
MyString(int buf_len = 64, const char * data = NULL)
{
this->buf_len = 0;
this->characters = NULL;
create(buf_len, data);
}
~MyString()
{
delete []this->characters;
}
// ...
};
```

### Dynamic Memory in Objects

```cpp
MyString str1(10, "Shenzhen");
MyString str2 = str1;
MyString str3;
str3 = str1;
```

**此处注意看讲解：**【快速学习C和C++，基础语法和优化策略，学了不再怕指针(南科大计算机系原版)】 【精准空降到 04:47】 https://www.bilibili.com/video/BV1Vf4y1P7pq/?p=48&share_source=copy_web&vd_source=ce7db4602809160957ede06f23353169&t=287

## 11.3 Solution1: Hard copy

> See: example2

### Copy Constructor

• Provide a user-defined copy constructor.

```cpp
MyString::MyString(const MyString & ms)
{
this->buf_len = 0;
this->characters = NULL;
create(ms.buf_len, ms.characters);
}
```

- `create()` release the current memory and allocate a new one .
- `this->characters` will not point to `ms.characters`.
- It's a hard copy!

### Copy Assignment

- Provide a user-defined copy assignment

  ```cpp
  MyString & operator=(const MyString &ms)
  {
  create(ms.buf_len, ms.characters);
  return *this;
  }
  ```

  

## 11.4 Solution2: Soft copy

### CvMat struct 

>  [modules/core/include/opencv2/core/types_c.h](modules/core/include/opencv2/core/types_c.h)

```cpp
typedef struct CvMat
{
    int type;
    int step;

    /* for internal use only */
    int* refcount;
    int hdr_refcount;

    union // union内指针共享内存（巧妙之处～
    {
        uchar* ptr;
        short* s;
        int* i;
        float* fl;
        double* db;
    } data;
```

|    ... | ...                               |
| -----: | --------------------------------- |
|    int | flags                             |
|    int | dims                              |
|    int | rows                              |
|    int | cols                              |
| uchar* | data                              |
|    int | refcount  // data被多少个对象引用 |
|    ... | ...                               |

### `cv::Mat class`

> 位置(20231012)：https://github.com/opencv/opencv/blob/7e17f01b7b43b756cb2d6a8b5c73548123b1fd74/modules/core/include/opencv2/core/mat.hpp#L810

`uchar* data` and `UMatData* u`  are allocated at the same time, `u`represents how many objects reference `data`.

![](images/Lecture11CvMat.png)

### Solution in OpenCV

1. **modules/core/src/matrix.cpp**

> https://github.com/opencv/opencv/blob/7e17f01b7b43b756cb2d6a8b5c73548123b1fd74/modules/core/src/matrix.cpp#L484

- The allocated memory can be used by multiple object
- `Mat::u->refcount` is used to count the times the memory is referenced
- `CV_XADD`: macro for atomic add （怎么翻译-。-）

```cpp
Mat& Mat::operator=(const Mat& m)
{
    if( this != &m )
    {
        if( m.u ) // u就是 上面的 UMatData* u
            CV_XADD(&m.u->refcount, 1); // 引用次数+1，并考虑到了并行运算
        release();
        flags = m.flags;
        if( dims <= 2 && m.dims <= 2 )
        {
            dims = m.dims;
            rows = m.rows;
            cols = m.cols;
            step[0] = m.step[0];
            step[1] = m.step[1];
        }
        else
            copySize(m);
        data = m.data; // refcount+1，同时data赋值
        datastart = m.datastart;
        dataend = m.dataend;
        datalimit = m.datalimit;
        allocator = m.allocator;
        u = m.u;
    }
    return *this;
}
```

2. **Copy constructor of cv::Mat**

​	modules/core/src/matrix.cpp

> https://github.com/opencv/opencv/blob/7e17f01b7b43b756cb2d6a8b5c73548123b1fd74/modules/core/src/matrix.cpp#L401

```cpp
Mat::Mat(const Mat& m)
    : flags(m.flags), dims(m.dims), rows(m.rows), cols(m.cols), data(m.data),  // data(m.data)
      datastart(m.datastart), dataend(m.dataend), datalimit(m.datalimit), allocator(m.allocator),
      u(m.u), size(&rows), step(0)
{
    if( u ) // u
        CV_XADD(&u->refcount, 1);
    if( m.dims <= 2 )
    {
        step[0] = m.step[0]; step[1] = m.step[1];
    }
    else
    {
        dims = 0;
        copySize(m);
    }
}
```

3. **`Mat::release()`**

   modules/core/src/matrix.cpp

   > https://github.com/opencv/opencv/blob/7e17f01b7b43b756cb2d6a8b5c73548123b1fd74/modules/core/src/matrix.cpp#L547

   ```c++
   void Mat::release() // 这个函数会被析构函数 或 其他有必要的地方 调用 - 解决多个对象共享内存的问题
   {
       if( u && CV_XADD(&u->refcount, -1) == 1 )  // 如果等于1，说明该对象是对该数据的唯一引用
           deallocate(); // 释放数据
       u = NULL;
       datastart = dataend = datalimit = data = 0;
       for(int i = 0; i < dims; i++)
           size.p[i] = 0;
   #ifdef _DEBUG
       flags = MAGIC_VAL;
       dims = rows = cols = 0;
       if(step.p != step.buf)
       {
           fastFree(step.p);
           step.p = step.buf;
           size.p = &rows;
       }
   #endif
   }
   ```

   

## 11.5 Smart pointers

### std::shared_ptr

- Smart pointers are used to make sure that an object can be deleted when it is no longer used. 😍

- Several shared pointers can share/point to the same object.

- The object is destroyed when no `shared_ptr` points to it.

  ```cpp
  std::shared_ptr<MyTime> mt1(new MyTime(10));
  std::shared_ptr<MyTime> mt2 = mt1;
  auto mt1 = std::make_shared<MyTime>(1, 70);
  ```

### std::unique_ptr

- Different from std::shared_ptr, a std::unique_ptr will point to an object, and not allow others to point to.

- But an object pointed by a std::unique_ptr can be moved to another pointer.

  ```cpp
  std::unique_ptr<MyTime> mt1(new MyTime(10));
  std::unique_ptr<MyTime> mt2 = std::make_unique<MyTime>(80); // c++17 才可以
  std::unique_ptr<MyTime> mt3 = std::move(mt1);
  ```

### How to Understand Smart Pointers

- Let’s look at their definitions.

  ```c++
  template< class T > class shared_ptr;
  
  template<
  	class T,
  	class Deleter = std::default_delete<T>
  > class unique_ptr;
  ```

  

- mt1 and mt2 are two objects of type shared_ptr<>.

  - You can do a lot in the constructors and the destructor.

    ```cpp
    std::shared_ptr<MyTime> mt1(new MyTime(10));
    std::shared_ptr<MyTime> mt2 = mt1;
    ```

    